<html><head>    <script>            function LinearSearch(arr,target){                var arraySize=arr.length();                for(var i=0;i<arraySize;i++)                {                    if(arr[i]==target)                    {                        return i;                    }                }                return -1;            }         </script></head>
<body>    <div>Analysis of Algorithms</div>    <p>Is a theoretical study of computer program performance and resource usage.</p>
    <h2>Sorting</h2>    <p>For a given input sequence (a1,a2,...an) the output sequence is (a1,a2..an) such that a1        <=a2<=a3..<=an </p>
            <ol>                <ol>                    <h3>Simple Sort</h3>                    <li><a href=#insertion>Insertion Sort</a></li>                    <li><a href=#selection>Selection Sort</a></li>                </ol>                <ol>                    <h3>Efficient Sort</h3>                    <li><a href=#merge>Merge Sort</a></li>                    <li><a href=#heap>Heap Sort</a></li>                    <li><a href=#quick>Quick Sort</a></li>                </ol>                <ol>                    <h3>Bubble Sort and Variants</h3>                    <li><a href=#bubble>Bubble Sort</a></li>                    <li><a href=#shell>ShellSort</a></li>                    <li><a href=#comb>Comb Sort</a></li>                </ol>                <ol>                    <h3>Distribution Sort</h3>                    <li><a href=#counting>Counting Sort</a></li>                    <li><a href=#bucket>Bucket Sort</a></li>                    <li><a href=#radix>Radix Sort</a></li>                </ol>
            </ol>
            <div id="insertion">                <h3>Insertion Sort</h3>                <p>Insertion sort(a,n) sorts a[1,2...n]</p>                <p>                    <h4>Pseudocode</h4>                    <pre>                        for i = 2 to n do                             key = A[i]                             j = i-1                             when j >= 0 and a[j] > key do                                 a[j+1] = a[j]                                 j=j-1                             done                             a[j+1]=key                         done                    </pre>                </p>                <p>                    <h4>Javascript</h4>                    <pre>                        <code>             function InsertionSort(arr){               var len=arr.length;               var i,j;               for(i=1;i<=len;i++)               {                     var key=arr[i];                    for(j=i-1; j>=0 && (arr[j]>key); j--)                    {                        arr[j+1]=arr[j];                                        }                    arr[j+1]=key;               }                            }          </code>                    </pre>                    <p>Asymptotic Anaylsis of Insertion is &Theta;(n<sup>2</sup>) </p>                 </p>                <div>Find the index of the given number using LinearSearch Algorithm</div>            <p>Please provide the array value</p> <input type="number" />            <button type="submit" onclick="LinearSearch()">Linear Search</button>            </div>            <div id="asymptotic">                 <h3> Analysis of Algorithm</h3>                <ul>                    <li> Depends on Input (Eg if it is already sorted)</li>                    <li> Depends on input Size</li>                    <li> Want Upper bound (it provides gurentee) </li>                </ul>                <h4> Kind of analysis</h4>                <ol>                    <li>                        <p> Worst case (usually)</p>                        <p> T(n) = Maximum time on any input of size n</p>                    </li>                    <li>                        <p> Average Case (sometimes)</p>                        <p> T(n) = Expected time over all input of size n</p>                    </li>                    <li>                        <p> Best Case (bogus) </p>                        <p> </p>                    </li>                </ol>                <p>To find out the performance of two algorithm we can run it on machine and find out the time taken. But there are problem with this approach for analysis of algorithms.</p>                <ul>                    <li>It might be possible that for some inputs, first algorithm performs better than the second and for some inputs second performs better (Dont look at the running time,Look at the growth of T(n) as n->~ )</li>                    <li>It might also be possible that for some inputs, first algorithm perform better on one machine and the second works better on other machine for some other inputs.(Ignore the machine dependent constants)</li>                </ul>                <h2>Asymptotic Analysis</h2>                <p>Asymptotic analysis is the big idea that handles above issues in analyzing algorithms, in asymptotic analysis , we evaluate the performance of an algorithm in terms of input size (we don't measure the actual running time)</p>                <p>We calculate, how does the time taken by an algorithm increases with the input size.</p>                <h3>Asymptotic Notation</h3>                <p>Asymptotic notations are mathematical tools to represent time complexity of algorithm for asymptotic analysis.</p>                <ol>                    <li>&Theta; Theta notations</li>                    <li>Big O Notations</li>                    <li>&Omega; Omega Notation</li>                </ol>                <h3>&Theta; Theta notations</h3>                <p> The theta notation bounds a functions from above and below, so it defines exact asymptotic behavior. A simple way to get Theta notation of an expression is to drop low order terms and ignore leading constants.</p>                <p>                    example: 3n<sup>3</sup>+90n<sup>2</sup>-5n+6048=&Theta;(n<sup>3</sup>)                </p>                <p>As n-> &infin; , &Theta;(n<sup>2</sup>) will always beat an algorithm with &Theta; (n<sup>3</sup>) algorithm </p>                <p>For a given function g(n), we denote &Theta;(g(n)) is following set of functions.                        <pre>                        &Theta;(g(n)) = {f(n): there exist positive constants c1, c2 and n0 such                         that 0 <= c1*g(n) <= f(n) <= c2*g(n) for all n >= n0}                        </pre>                    The above definition means, if f(n) is theta of g(n), then the value f(n) is always between c1*g(n) and c2*g(n) for large values of n (n >= n0). The definition of theta also requires that f(n) must be non-negative for values of n greater than n0.                </p>                <h3>Big O Notation</h3>                <p> The big O notation defines an upper bound of an algorithm, it bounds a function only from above, For example consider the case of Inserartion Sort. it takes linear time                     in best case and quadratic time in worst case. We can safely say that the time complexity of Inseration sort is O(n <sup>2</sup>). Note that  O(n<sup>2</sup>) also covers linear time.            </div>                                           </body>
</html>
